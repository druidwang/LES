SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

SET ANSI_PADDING ON
GO

IF EXISTS(SELECT * FROM sys.objects WHERE type='P' AND name='USP_REC_INV_IN') 
     DROP PROCEDURE [USP_REC_INV_IN] 
GO

CREATE PROCEDURE [dbo].[USP_REC_INV_IN] 
(
	@VOU_NO VARCHAR(20),
	@ORD_NO VARCHAR(20),
	@ORD_TP CHAR(1),
	@DLV_NO VARCHAR(20),
	@PTY_CD VARCHAR(20),
	@TRANS_TP CHAR(3),
	@IO_TP CHAR(1),
	@EFF_DT DATE,
	@EFF_USR_CD VARCHAR(20)
) --WITH ENCRYPTION
AS 
BEGIN
	SET NOCOUNT ON

	DECLARE @ERROR_MSG NVARCHAR(MAX)
	DECLARE @DATETIME_NOW DATETIME
	DECLARE @UPD_CNT INT
	DECLARE @IS_BC BIT
	DECLARE @INV_TRANS_ID BIGINT

	SET @DATETIME_NOW = GETDATE()

	IF @EFF_DT IS NULL
	BEGIN
		SET @EFF_DT = CONVERT(VARCHAR(10), @DATETIME_NOW, 120)
	END

	BEGIN TRY
		IF NOT EXISTS(SELECT TOP 1 1 FROM tempdb.sys.objects WHERE type = 'U' AND name LIKE '#TMP_REC_INV_IN_INPUT')
		BEGIN
			SET @ERROR_MSG = '没有定义临时表#TMP_REC_INV_IN_INPUT表。'
			RAISERROR(@ERROR_MSG, 16, 1) 

			--收货入库输入参数表
			CREATE TABLE #TMP_REC_INV_IN_INPUT (
				VOU_LN INT PRIMARY KEY,
				ORD_LN INT,
				DLV_LN INT,
				PT_NO VARCHAR(20),
				UOM VARCHAR(3),
				BASE_UOM VARCHAR(3),
				UOM_CONV_RT DECIMAL(18, 8),
				LOC_CD VARCHAR(20),
				QLTY_TP CHAR(1),
				IS_FRZ BIT,
				IS_BC BIT,
				IS_TR BIT,
				IS_CNMT BIT,
				QTY DECIMAL(18, 8),
				RSN_CD CHAR(3),
				INV_BN_ID INT,
				VER INT
			)

			--条码入库输入参数表
			CREATE TABLE #TMP_REC_INV_IN_BC_INPUT (
				BAR_CD VARCHAR(20) PRIMARY KEY,
				VOU_LN INT,
				QTY DECIMAL(18, 8),
				UOM VARCHAR(3),
				BASE_UOM VARCHAR(3),
				UOM_CONV_RT DECIMAL(18, 8)
			)
		END

		IF EXISTS(SELECT TOP 1 1 FROM tempdb.sys.objects WHERE type = 'U' AND name LIKE '#TMP_REC_INV_IN_BC_INPUT')
		BEGIN  --按条码入库处理
			SET @IS_BC = 1
		END
		ELSE
		BEGIN  --按数量入库处理
			SET @IS_BC = 0
		END

		--记录需要更新的库存余额表记录数量
		SELECT @UPD_CNT = COUNT(1) FROM #TMP_REC_INV_IN_INPUT WHERE INV_BN_ID IS NOT NULL 

		--更新库存余额表
		UPDATE A SET QTY = A.QTY + B.QTY * B.UOM_CONV_RT, A.VER = A.VER + 1
		FROM INV_BN AS A INNER JOIN #TMP_REC_INV_IN_INPUT AS B ON A.INV_BN_ID = B.INV_BN_ID AND A.VER = B.VER
		
		--如果已经更新的库存余额表记录数量和@UPD_CNT
		IF (@@ROWCOUNT <> @UPD_CNT)
		BEGIN
			RAISERROR(N'数据已经被更新，请重试。', 16, 1)
		END

		--新增库存余额表记录
		INSERT INTO INV_BN(PT_NO, LOC_CD, QLTY_TP, IS_FRZ, IS_TR, IS_CNMT, QTY, VER)
		SELECT PT_NO, LOC_CD, QLTY_TP, IS_FRZ, IS_TR, IS_CNMT, QTY * UOM_CONV_RT, 1 
		FROM #TMP_REC_INV_IN_INPUT WHERE INV_BN_ID IS NULL

		--#TMP_REC_INV_IN_INPUT临时表更新新增的库存余额表ID
		UPDATE A SET INV_BN_ID = B.INV_BN_ID
		FROM #TMP_REC_INV_IN_INPUT AS A INNER JOIN INV_BN AS B ON A.PT_NO = B.PT_NO 
															 AND A.LOC_CD = B.LOC_CD
															 AND A.QLTY_TP = B.QLTY_TP
															 AND A.IS_FRZ = B.IS_FRZ
															 AND A.IS_BC = B.IS_BC
															 AND A.IS_TR = B.IS_TR
															 AND A.IS_CNMT = B.IS_CNMT
		WHERE A.INV_BN_ID IS NULL
		
		--记录库存余额表和条码的匹配关系
		IF @IS_BC = 1
		BEGIN
			INSERT INTO INV_BN_BC(INV_BN_ID, BAR_CD, QTY, IS_ACT, CRT_DT, CRT_USR_CD, UPD_DT, UPD_USR_CD)
			SELECT A.INV_BN_ID, B.BAR_CD, B.QTY * B.UOM_CONV_RT, 1, @DATETIME_NOW, @EFF_USR_CD, @DATETIME_NOW, @EFF_USR_CD
			FROM #TMP_REC_INV_IN_INPUT AS A INNER JOIN #TMP_REC_INV_IN_BC_INPUT AS B ON A.VOU_LN = B.VOU_LN
		END

		--新增库存事务头表记录
		INSERT INTO INV_TRANS(ORD_NO, ORD_TP, DLV_NO, VOU_NO, PTY_CD, TRANS_TP, IO_TP, EFF_DT, CRT_DT, CRT_USR_CD)
		VALUES(@ORD_NO, @ORD_TP, @DLV_NO, @VOU_NO, @PTY_CD, @TRANS_TP, @IO_TP, @EFF_DT, @DATETIME_NOW, @EFF_USR_CD)

		--记录库存事务头表ID
		SET @INV_TRANS_ID = @@IDENTITY

		--新增库存事务明细表记录
		INSERT INTO INV_TRANS_DET(INV_TRANS_ID, INV_TRANS_LN, ORD_LN, DLV_LN, VOU_LN, PT_NO, UOM, BASE_UOM, UOM_CONV_RT, 
									QTY, QLTY_TP, RSN_CD, LOC_CD)
		SELECT @INV_TRANS_ID, VOU_LN, ORD_LN, DLV_LN, VOU_LN, PT_NO, UOM, BASE_UOM, UOM_CONV_RT, 
					QTY, QLTY_TP, RSN_CD, LOC_CD 
		FROM #TMP_REC_INV_IN_INPUT

		--新增库存事务明细表和条码的匹配关系
		IF @IS_BC = 1
		BEGIN
			INSERT INTO INV_TRANS_BC(INV_TRANS_ID, INV_TRANS_LN, BAR_CD, QTY)
			SELECT @INV_TRANS_ID, A.VOU_LN, B.BAR_CD, B.QTY
			FROM #TMP_REC_INV_IN_INPUT AS A INNER JOIN #TMP_REC_INV_IN_BC_INPUT AS B ON A.VOU_LN = B.VOU_LN
		END

		--记录库存余额表和冻结库存的匹配关系
		--处理数量
		INSERT INTO INV_BN_FRZ(INV_BN_ID, FRZ_TP, FRZ_ORD_NO, FRZ_QTY, UN_FRZ_QTY, IS_ACT, CRT_DT, CRT_USR_CD, UPD_DT, UPD_USR_CD)
		SELECT INV_BN_ID, @ORD_TP, @ORD_NO, QTY * UOM_CONV_RT, 0, 1, @DATETIME_NOW, @EFF_USR_CD, @DATETIME_NOW, @EFF_USR_CD
		FROM #TMP_REC_INV_IN_INPUT 
		WHERE IS_FRZ = 1 AND IS_BC = 0

		--记录库存余额表和冻结库存的匹配关系
		--处理条码
		IF @IS_BC = 1
		BEGIN
			INSERT INTO INV_BN_FRZ(INV_BN_ID, FRZ_TP, FRZ_ORD_NO, FRZ_BC, FRZ_QTY, UN_FRZ_QTY, IS_ACT, CRT_DT, CRT_USR_CD, UPD_DT, UPD_USR_CD)
			SELECT A.INV_BN_ID, @ORD_TP, @ORD_NO, B.BAR_CD, B.QTY * B.UOM_CONV_RT, 0, 1, @DATETIME_NOW, @EFF_USR_CD, @DATETIME_NOW, @EFF_USR_CD
			FROM #TMP_REC_INV_IN_INPUT AS A INNER JOIN #TMP_REC_INV_IN_BC_INPUT AS B ON A.VOU_LN = B.VOU_LN
			WHERE A.IS_FRZ = 1
		END
	END TRY
	BEGIN CATCH
		SET @ERROR_MSG = N'程序执行时发生错误:' + ERROR_MESSAGE() + N'，行数：' + ERROR_LINE()
		RAISERROR(@ERROR_MSG, 16, 1) 
	END CATCH
END
GO